// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC1155/ERC1155.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Pausable.sol";
import "@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Supply.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
import "@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol";
import "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";
import "@openzeppelin/contracts/utils/Strings.sol";

import "./interfaces/OptimisticOracleV3Interface.sol";

contract NFLinks is
    ERC1155,
    Ownable,
    ERC1155Supply,
    ERC1155Pausable,
    ERC1155Holder
{
    OptimisticOracleV3Interface public oov3;

    uint256 public constant CALCULATION_DENOMINATOR = 10000;
    uint256 public mintPriceIncreaseNumerator;

    struct NFT {
        uint256 chainId;
        address tokenAddress;
        uint256 tokenId;
    }

    struct CashoutRequest {
        bytes32 assertionId;
        address suggestedOwner;
    }

    // from linkerId -> cashout request
    mapping(uint256 => CashoutRequest) public cashoutRequests;

    uint256 public availableSeats;

    mapping(address => bool) public members;
    // This mapping associates users with their referrers, helping to identify who referred a given user.
    mapping(address => address) public referrers;

    // This array will hold the mint prices based on supply ; supply will be passed as index;
    uint256[] public mintPrices;

    // will be use to make sure that owner doesn't increase the share more than this
    uint256 public constant MAX_REFERRAL_SHARE_NUMERATOR = 1500;
    uint256 public constant MAX_SYSTEM_SHARE_NUMERATOR = 1500;

    uint256 public referralShareNumerator = 1500;
    uint256 public systemShareNumerator = 1500;

    uint256 public systemBalance;
    mapping(address => uint256) public referralBalances;
    // Linker ID  ->  balances;
    mapping(uint256 => uint256) public tokenBalances;

    constructor(
        address initialOwner_,
        uint256 initialSeats_,
        uint256 initialPrice_,
        uint256 priceIncreaseNumerator_,
        address umaV3_
    ) ERC1155("") Ownable(initialOwner_) {
        availableSeats = initialSeats_;
        // Setting up the initial price of minting
        // It will be in polygon so 1 matic is the initial price
        mintPrices.push(initialPrice_);
        mintPriceIncreaseNumerator = priceIncreaseNumerator_;
        oov3 = OptimisticOracleV3Interface(umaV3_);
    }

    /**
     * @dev Sets the next mint price for creating a new linker token. The new price is calculated based on
     * the last recorded price in the `mintPrices` array, increasing it by a specified ratio. The calculated
     * price is then added to the `mintPrices` array.
     *
     * @return price The newly calculated mint price as a uint256.
     */
    function setNextMintPrice() public returns (uint256 price) {
        price =
            (mintPrices[mintPrices.length - 1] *
                (CALCULATION_DENOMINATOR + mintPriceIncreaseNumerator)) /
            CALCULATION_DENOMINATOR;
        mintPrices.push(price);
    }

    /**
     * @dev Figures out the mint price for creating a new linker token based on the linker token's supply.
     * If the supply is less than the number of recorded mint prices, the function retrieves the price from
     * the `mintPrices` array. Otherwise, it calls `setNextMintPrice` to calculate the next mint price.
     *
     * @param linkerId_ The ID of the linker token for which the mint price is determined.
     * @return price The calculated mint price as a uint256.
     */
    function figureMintPrice(uint256 linkerId_) public returns (uint256 price) {
        uint256 supply = totalSupply(linkerId_);
        if (supply < mintPrices.length) {
            price = mintPrices[supply];
        } else {
            // since always this function is called increamentally we won't miss any supply
            price = setNextMintPrice();
        }
    }

    /**
     * @dev Calculates a unique linker token ID for an ERC721 NFT based on the combination of its chain ID,
     * token address, and token ID. The ID is generated by hashing the concatenated values and converting
     * the result into a uint256.
     *
     * @param nft_ The NFT struct containing the chain ID, token address, and token ID.
     * @return id The computed linker token ID as a uint256.
     */
    function calculateLinkerId(
        NFT memory nft_
    ) public pure returns (uint256 id) {
        bytes32 hash = keccak256(
            abi.encodePacked(nft_.chainId, nft_.tokenAddress, nft_.tokenId)
        );
        id = uint256(hash);
    }

    /**
     * @dev Calculates a unique link token ID to connect two NFTs together. To create a link to a target NFT,
     * you need the linker token of the target NFT. The ID is generated by hashing the combination of the
     * linker token IDs of the subject NFT and the target NFT.
     *
     * @param subject_ The subject NFT that initiates the link.
     * @param target_ The target NFT to which the link is created.
     * @return id The computed link token ID as a uint256.
     */
    function calculateLinkId(
        NFT memory subject_,
        NFT memory target_
    ) public pure returns (uint256 id) {
        bytes32 hash = keccak256(
            abi.encodePacked(
                calculateLinkerId(subject_),
                calculateLinkerId(target_)
            )
        );
        id = uint256(hash);
    }

    /**
     * @dev Calculates a unique referral token ID for a user based on their address. The ID is
     * generated by casting the address to a uint256.
     *
     * @param referrer_ The Ethereum address of the user for whom the referral token ID is to be calculated.
     * @return id The computed referral token ID as a uint256.
     */
    function calculateReferralTokenId(
        address referrer_
    ) public pure returns (uint256 id) {
        id = uint256(uint160(referrer_));
    }

    /**
     * @dev Mints a new referral token for a user, either when they mint a new linker token or using a seat. The referral token
     * is minted for the specified recipient's address and is assigned a unique ID calculated based on the
     * referrer's address. An event is emitted to log the minting of the referral token.
     *
     * @param referrer_ The Ethereum address of the user who referred the minting of a linker token.
     * @param to_ The Ethereum address of the recipient of the minted referral token.
     */
    function _mintReferralToken(address referrer_, address to_) internal {
        // must mint a token for the user
        _mint(to_, calculateReferralTokenId(referrer_), 1, "");
        // must emit an event
        emit ReferralTokenMint(to_, calculateReferralTokenId(referrer_));
    }

    /**
     * @dev Registers a consumer with a referrer in the referral program. This function should only
     * be called by the consumer themselves. It associates the consumer's address with a referrer's
     * address in the referral program.
     *
     * @param referrer_ The Ethereum address of the referrer.
     * @param consumer_ The Ethereum address of the consumer registering.
     */
    function register(address referrer_, address consumer_) public {
        require(msg.sender == consumer_, "unauthorized");
        _register(referrer_, consumer_);
    }

    /**
     * @dev Registers a consumer with a referrer in the referral program using a cryptographic signature
     * for authentication. This function verifies the provided signature against a predefined message,
     * associating the consumer's address with a referrer's address in the referral program.
     *
     * @param referrer_ The Ethereum address of the referrer.
     * @param consumer_ The Ethereum address of the consumer registering.
     * @param signature_ The cryptographic signature for authentication.
     */
    function registerWithSignature(
        address referrer_,
        address consumer_,
        bytes memory signature_
    ) public {
        // TODO: This function needs more work to be more secure
        bytes memory message = "REGISTER ME";
        bytes32 messageHash = MessageHashUtils.toEthSignedMessageHash(message);
        require(
            ECDSA.recover(messageHash, signature_) == consumer_,
            "not consumer"
        );
        _register(referrer_, consumer_);
    }

    /**
     * @dev Internal function to handle the registration process. Registers a consumer with a referrer
     * in the referral program by updating data structures and emitting an event. This function should
     * only be called from other functions within the contract.
     *
     * @param referrer_ The Ethereum address of the referrer.
     * @param consumer_ The Ethereum address of the consumer registering.
     */
    function _register(address referrer_, address consumer_) internal {
        require(members[consumer_] == false, "already registered");
        _burn(msg.sender, calculateReferralTokenId(referrer_), 1);
        members[consumer_] = true;
        referrers[consumer_] = referrer_;
        emit UserRegistered(consumer_, referrer_);
    }

    function registerAndMint(
        NFT memory target_,
        address to_,
        address referrer_
    ) public payable {
        _registerWithSeatOption(referrer_, to_);
        _mint(target_, to_);
    }

    function mint(NFT memory target_, address to_) public payable {
        require(members[to_], "not registered");
        _mint(target_, to_);
    }

    function _mint(NFT memory target_, address to_) internal {
        // check the msg.value mint price
        uint256 linkerId = calculateLinkerId(target_);
        uint256 mintPrice = figureMintPrice(calculateLinkerId(target_));
        require(msg.value == mintPrice, "wrong value");

        //  accounting stuffs
        uint256 referrerShare;
        uint256 systemShare;
        uint256 tokenShare;

        if (referrers[msg.sender] != address(0)) {
            referrerShare =
                (msg.value * (referralShareNumerator)) /
                CALCULATION_DENOMINATOR;

            systemShare =
                (msg.value * (systemShareNumerator)) /
                CALCULATION_DENOMINATOR;
        } else {
            systemShare =
                (msg.value * (systemShareNumerator + referralShareNumerator)) /
                CALCULATION_DENOMINATOR;
        }

        referralBalances[referrers[msg.sender]] += referrerShare;
        systemBalance += systemShare;

        tokenShare = msg.value - (referrerShare + systemShare);
        tokenBalances[linkerId] += tokenShare;

        // _mintLinker
        _mint(to_, linkerId, 1, "");
        // emit event
        emit LinkerMinted(
            linkerId,
            target_.chainId,
            target_.tokenAddress,
            target_.tokenId,
            mintPrice,
            systemShare,
            referrerShare,
            referrers[msg.sender],
            tokenShare
        );
        _mintReferralToken(to_, to_);
    }

    /**
     * @dev Internal function to handle the registration process with an option for reserving a seat in the
     * referral program. If `referrer_` is set to the zero address (address(0)), the function checks for
     * available seats, reserves a seat for the consumer, mints a referral token for the consumer, and
     * associates the consumer's address with the zero address as the referrer. If `referrer_` is not the
     * zero address, it proceeds with the regular registration process.
     *
     * @param referrer_ The Ethereum address of the referrer. Use address(0) to reserve a seat.
     * @param consumer_ The Ethereum address of the consumer registering.
     */
    function _registerWithSeatOption(
        address referrer_,
        address consumer_
    ) internal {
        if (referrer_ == address(0)) {
            require(availableSeats > 0, "no seat");
            availableSeats--;
            _mintReferralToken(address(0), msg.sender);
            _register(referrer_, consumer_);
        } else {
            _register(referrer_, consumer_);
        }
    }

    /**
     * @dev Creates a link between two NFTs with a specified weight. To establish a link, the subject NFT
     * (`subject_`) must not be the same as the target NFT (`target_`). The caller must have a sufficient
     * balance of linker tokens associated with the target NFT to cover the specified weight. The linker
     * tokens are transferred from the caller to this contract, and a corresponding linked token is minted.
     *
     * @param subject_ The NFT that initiates the link.
     * @param target_ The NFT to which the link is created.
     * @param weight_ The weight of the link, determining its significance.
     */
    function link(
        NFT memory subject_,
        NFT memory target_,
        uint256 weight_
    ) public {
        require(
            calculateLinkerId(subject_) != calculateLinkerId(target_),
            "self-link prohibited"
        );
        require(
            balanceOf(msg.sender, calculateLinkerId(target_)) >= weight_,
            "not enough linker"
        );
        _safeTransferFrom(
            msg.sender,
            address(this),
            calculateLinkerId(target_),
            weight_,
            ""
        );
        _mint(msg.sender, calculateLinkId(subject_, target_), weight_, "");
        emit Linked(
            calculateLinkId(subject_, target_),
            calculateLinkerId(subject_),
            calculateLinkerId(target_),
            subject_.chainId,
            subject_.tokenAddress,
            subject_.tokenId,
            target_.chainId,
            target_.tokenAddress,
            target_.tokenId,
            weight_
        );
    }

    /**
     * @dev Removes a link between two NFTs with a specified weight. The caller must have a sufficient balance
     * of linked tokens representing the link to be removed (`subject_` and `target_`) to cover the specified
     * weight. The linked tokens are burned, and the corresponding linker tokens are transferred back to the caller.
     *
     * @param subject_ The NFT that initiates the link.
     * @param target_ The NFT from which the link is removed.
     * @param weight_ The weight of the link to be removed.
     */
    function delink(
        NFT memory subject_,
        NFT memory target_,
        uint256 weight_
    ) public {
        uint256 linkId = calculateLinkId(subject_, target_);
        require(balanceOf(msg.sender, linkId) >= weight_, "not enough link");
        _burn(msg.sender, linkId, weight_);
        _safeTransferFrom(
            address(this),
            msg.sender,
            calculateLinkerId(target_),
            weight_,
            ""
        );
        emit DeLinked(
            linkId,
            calculateLinkerId(subject_),
            calculateLinkerId(target_),
            subject_.chainId,
            subject_.tokenAddress,
            subject_.tokenId,
            target_.chainId,
            target_.tokenAddress,
            target_.tokenId,
            weight_
        );
    }

    function requestCashout(NFT memory nft_, address suggestedOwner_) public {
        bytes32 assertionId = oov3.assertTruthWithDefaults(
            bytes(
                string.concat(
                    "owner of nft with chainId: ",
                    Strings.toString(nft_.chainId),
                    ", address: ",
                    Strings.toHexString(nft_.tokenAddress),
                    "and token i: ",
                    Strings.toString(nft_.tokenId),
                    "is: ",
                    Strings.toHexString(suggestedOwner_)
                )
            ),
            msg.sender
        );
        cashoutRequests[calculateLinkerId(nft_)] = CashoutRequest(
            assertionId,
            suggestedOwner_
        );
        emit CashoutRequested(
            nft_.chainId,
            nft_.tokenAddress,
            nft_.tokenId,
            suggestedOwner_
        );
    }

    function settleCashout(NFT memory nft_) public {
        uint256 linkId = calculateLinkerId(nft_);
        CashoutRequest memory request = cashoutRequests[
            calculateLinkerId(nft_)
        ];
        bool assertionResult = oov3.settleAndGetAssertionResult(
            request.assertionId
        );
        require(assertionResult, "assertion failed.");
        uint256 tokenBalance = tokenBalances[linkId];
        tokenBalances[linkId] = 0;
        (bool sent, ) = request.suggestedOwner.call{value: tokenBalance}("");
        require(sent, "Failed to send money");
        emit CashoutSettled(
            nft_.chainId,
            nft_.tokenAddress,
            nft_.tokenId,
            request.suggestedOwner,
            tokenBalance
        );
        delete cashoutRequests[calculateLinkerId(nft_)];
    }

    // The following functions are overrides required by Solidity.
    function _update(
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory values
    ) internal override(ERC1155, ERC1155Pausable, ERC1155Supply) {
        super._update(from, to, ids, values);
    }

    function supportsInterface(
        bytes4 interfaceId
    ) public view override(ERC1155, ERC1155Holder) returns (bool) {
        return super.supportsInterface(interfaceId);
    }

    /// events
    event ReferralTokenMint(address referrer_, uint256 tokenId_);
    event UserRegistered(address user_, address referrer_);
    event LinkerMinted(
        uint256 indexed linkerId_,
        uint256 chainId_,
        address tokenAddress_,
        uint256 tokenId_,
        uint256 mintPrice_,
        uint256 systemShare_,
        uint256 referrerShare_,
        address referrer,
        uint256 tokenShare_
    );
    event Linked(
        uint256 indexed linkId_,
        uint256 indexed subjectLinkerId_,
        uint256 indexed objectLinkerId_,
        uint256 subjectChainId_,
        address subjectTokenAddress_,
        uint256 subjectTokenId_,
        uint256 objectChainId_,
        address objectTokenAddress_,
        uint256 objectTokenId_,
        uint256 weight
    );
    event DeLinked(
        uint256 indexed linkId_,
        uint256 indexed subjectLinkerId_,
        uint256 indexed objectLinkerId_,
        uint256 subjectChainId_,
        address subjectTokenAddress_,
        uint256 subjectTokenId_,
        uint256 objectChainId_,
        address objectTokenAddress_,
        uint256 objectTokenId_,
        uint256 weight
    );
    event CashoutRequested(
        uint256 chainId_,
        address tokenAddress_,
        uint256 tokenId_,
        address suggestedOwner_
    );
    event CashoutSettled(
        uint256 chainId_,
        address tokenAddress_,
        uint256 tokenId_,
        address suggestedOwner_,
        uint256 amount_
    );
}
