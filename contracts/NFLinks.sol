// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC1155/ERC1155.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Burnable.sol";
import "@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Supply.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
import "@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol";

import "hardhat/console.sol";

contract NFLinks is ERC1155, Ownable, ERC1155Supply {
    struct NFT {
        uint256 chainId;
        address tokenAddress;
        uint256 tokenId;
    }

    uint256 public availableSeats;

    mapping(address => bool) public members;
    // This mapping associates users with their referrers, helping to identify who referred a given user.
    mapping(address => address) public referrers;

    constructor(
        address initialOwner_,
        uint256 initialSeats_
    ) ERC1155("") Ownable(initialOwner_) {
        availableSeats = initialSeats_;
    }

    /**
     * @dev Calculates a unique linker token ID for an ERC721 NFT based on the combination of its chain ID,
     * token address, and token ID. The ID is generated by hashing the concatenated values and converting
     * the result into a uint256.
     *
     * @param nft_ The NFT struct containing the chain ID, token address, and token ID.
     * @return id The computed linker token ID as a uint256.
     */
    function calculateLinkerId(
        NFT memory nft_
    ) public pure returns (uint256 id) {
        bytes32 hash = keccak256(
            abi.encodePacked(nft_.chainId, nft_.tokenAddress, nft_.tokenId)
        );
        id = uint256(hash);
    }

    /**
     * @dev Calculates a unique referral token ID for a user based on their address. The ID is
     * generated by casting the address to a uint256.
     *
     * @param referrer_ The Ethereum address of the user for whom the referral token ID is to be calculated.
     * @return id The computed referral token ID as a uint256.
     */
    function calculateReferralTokenId(
        address referrer_
    ) public pure returns (uint256 id) {
        id = uint256(uint160(referrer_));
    }

    /**
     * @dev Mints a new referral token for a user when they mint a new linker token. The referral token
     * is minted for the specified referrer's address and is assigned a unique ID calculated based on the
     * referrer's address. An event is emitted to log the minting of the referral token.
     *
     * @param referrer_ The Ethereum address of the user who referred the minting of a linker token.
     */
    function _mintReferralToken(address referrer_) internal {
        // must mint a token for the user
        _mint(referrer_, calculateReferralTokenId(referrer_), 1, "");
        // must emit an event
        emit ReferralTokenMint(referrer_, calculateReferralTokenId(referrer_));
    }

    /**
     * @dev Registers a consumer with a referrer in the referral program. This function should only
     * be called by the consumer themselves. It associates the consumer's address with a referrer's
     * address in the referral program.
     *
     * @param referrer_ The Ethereum address of the referrer.
     * @param consumer_ The Ethereum address of the consumer registering.
     */
    function register(address referrer_, address consumer_) public {
        require(msg.sender == consumer_, "unauthorized");
        _register(referrer_, consumer_);
    }

    /**
     * @dev Registers a consumer with a referrer in the referral program using a cryptographic signature
     * for authentication. This function verifies the provided signature against a predefined message,
     * associating the consumer's address with a referrer's address in the referral program.
     *
     * @param referrer_ The Ethereum address of the referrer.
     * @param consumer_ The Ethereum address of the consumer registering.
     * @param signature_ The cryptographic signature for authentication.
     */
    function registerWithSignature(
        address referrer_,
        address consumer_,
        bytes memory signature_
    ) public {
        // TODO: This function needs more work to be more secure
        bytes memory message = "REGISTER ME";
        bytes32 messageHash = MessageHashUtils.toEthSignedMessageHash(message);
        require(
            ECDSA.recover(messageHash, signature_) == consumer_,
            "not consumer"
        );
        _register(referrer_, consumer_);
    }

    /**
     * @dev Internal function to handle the registration process. Registers a consumer with a referrer
     * in the referral program by updating data structures and emitting an event. This function should
     * only be called from other functions within the contract.
     *
     * @param referrer_ The Ethereum address of the referrer.
     * @param consumer_ The Ethereum address of the consumer registering.
     */
    function _register(address referrer_, address consumer_) internal {
        require(members[consumer_] == false, "already registered");
        _burn(msg.sender, calculateReferralTokenId(referrer_), 1);
        members[consumer_] = true;
        referrers[consumer_] = referrer_;
        emit UserRegistered(consumer_, referrer_);
    }

    // The following functions are overrides required by Solidity.

    function _update(
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory values
    ) internal override(ERC1155, ERC1155Supply) {
        super._update(from, to, ids, values);
    }

    /// events
    event ReferralTokenMint(address referrer_, uint256 tokenId_);
    event UserRegistered(address user_, address referrer_);
}
